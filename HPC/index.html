<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lecture: The Power of Parallel - Intro to CUDA</title>
    <!-- Importing a nice font for readability -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #76B900; /* NVIDIA Green-ish */
            --dark: #1a1a1a;
            --light: #f4f4f4;
            --code-bg: #2d2d2d;
            --accent: #2c3e50;
            --cpu-color: #3498db;
            --gpu-color: #e74c3c;
            --warp-active: #2ecc71;
            --warp-inactive: #95a5a6;
            --kernel-bg: #4a4a4a;
        }

        body {
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: var(--light);
        }

        /* Header / Hero Section */
        header {
            background-color: var(--dark);
            color: white;
            padding: 4rem 2rem;
            text-align: center;
            border-bottom: 6px solid var(--primary);
        }

        header h1 {
            font-size: 3rem;
            margin: 0;
            font-weight: 800;
        }

        header .subtitle {
            font-size: 1.2rem;
            color: #ccc;
            margin-top: 1rem;
        }

        header .meta {
            font-size: 0.9rem;
            color: var(--primary);
            margin-top: 2rem;
            font-weight: 600;
        }

        /* Main Content Container */
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.05);
            min-height: 100vh;
        }

        /* Sections */
        section {
            margin-bottom: 4rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid #eee;
        }

        section:last-child {
            border-bottom: none;
        }

        h2 {
            color: var(--accent);
            font-size: 2rem;
            margin-top: 0;
            display: flex;
            align-items: center;
        }

        h2::before {
            content: '';
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: var(--primary);
            margin-right: 15px;
            border-radius: 50%;
        }

        h3 {
            color: var(--dark);
            font-size: 1.4rem;
            margin-top: 2rem;
        }

        p {
            font-size: 1.1rem;
            color: #555;
        }

        /* Concept Boxes */
        .analogy-box {
            background-color: #e8f4f8;
            border-left: 5px solid #3498db;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }

        .analogy-title {
            font-weight: bold;
            color: #2980b9;
            text-transform: uppercase;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            display: block;
        }

        .highlight-box {
            background-color: #f0f9eb;
            border-left: 5px solid var(--primary);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }

        /* Code Styling */
        pre {
            background-color: var(--code-bg);
            color: #e0e0e0;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            border: 1px solid #444;
        }

        code {
            font-family: 'Fira Code', monospace;
        }

        .inline-code {
            background-color: #eee;
            color: #d63384;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        /* Custom Syntax Highlighting (Simulated) */
        .c-keyword { color: #cc99cd; } /* Purple */
        .c-type { color: #e1a67a; }    /* Orange */
        .c-func { color: #61aeee; }    /* Blue */
        .c-comment { color: #999; font-style: italic; }
        .c-num { color: #f08d49; }
        .cuda-keyword { color: #2ecc71; font-weight: bold; } /* Green for __global__ etc */
        .special-launch { color: #f1c40f; font-weight: bold; } /* Yellow for <<<>>> */

        /* INTERACTIVE DEMO STYLES */
        .demo-container {
            background: #fafafa;
            border: 2px solid #eee;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .demo-controls {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        button.btn-demo {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
            transition: transform 0.1s;
        }

        button.btn-cpu { background-color: var(--cpu-color); color: white; }
        button.btn-gpu { background-color: var(--gpu-color); color: white; }
        button.btn-reset { background-color: #95a5a6; color: white; }
        button.btn-warp { background-color: #8e44ad; color: white; }
        button:active { transform: scale(0.95); }

        /* Visualization 2 & 4: Grid Explorer */
        .grid-visualizer {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
        }

        .block-container {
            border: 2px dashed #999;
            padding: 10px;
            border-radius: 8px;
            background: white;
            position: relative;
        }
        
        .block-label {
            position: absolute;
            top: -12px;
            left: 10px;
            background: white;
            padding: 0 5px;
            font-size: 0.8rem;
            font-weight: bold;
            color: #666;
        }

        .thread-row {
            display: flex;
            gap: 5px;
        }

        .thread-box {
            width: 40px;
            height: 40px;
            background-color: #ddd;
            border: 1px solid #bbb;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .thread-box:hover, .thread-box.active {
            background-color: var(--primary);
            color: white;
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 10;
        }
        
        .thread-box .t-id { font-weight: bold; }
        .thread-box .g-idx { font-size: 0.7rem; }

        .math-display {
            background: #2c3e50;
            color: #fff;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Fira Code', monospace;
            margin-top: 20px;
            font-size: 1.1rem;
        }
        
        .variable { color: #f1c40f; }
        .result { color: #2ecc71; font-weight: bold; }

        /* Visualization 3: Warp Divergence */
        .warp-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }

        .warp-row {
            display: flex;
            gap: 5px;
        }

        .warp-thread {
            width: 30px;
            height: 30px;
            background-color: #ddd;
            border-radius: 4px;
            border: 1px solid #ccc;
            transition: background-color 0.2s;
        }

        .timeline-bar {
            width: 80%;
            height: 20px;
            background-color: #eee;
            border-radius: 10px;
            margin-top: 15px;
            position: relative;
            overflow: hidden;
            border: 1px solid #ccc;
        }

        .timeline-fill {
            height: 100%;
            width: 0%;
            background-color: var(--primary);
            transition: width 0.5s linear;
        }
        
        .divergence-message {
            font-weight: bold;
            min-height: 24px;
            color: var(--accent);
        }
        
        /* Execution Simulator Output */
        #executionOutput {
            text-align: left;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #fff;
            min-height: 100px;
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 2rem;
            font-size: 0.9rem;
            color: #888;
            border-top: 1px solid #eee;
        }
    </style>
</head>
<body>

<header>
    <h1>The Power of Parallel</h1>
    <div class="subtitle">An Interactive Intro to GPU Programming with CUDA</div>
    <div class="meta">Group: [Student Names] • Date: Dec 4, 2025</div>
</header>

<div class="container">

    <!-- SECTION 1: THE CONCEPT -->
    <section id="concept">
        <h2>1. The Big Idea: CPU vs. GPU</h2>
        <p>Before looking at code, we need to understand the fundamental difference between the processor in your laptop (CPU) and the graphics card (GPU).</p>

        <div class="analogy-box">
            <span class="analogy-title">The "Kitchen" Analogy</span>
            <p><strong>The CPU is a Master Chef.</strong> They are incredibly smart, can cook complex recipes, manage the restaurant, and solve difficult problems. But, they can only chop one onion at a time.</p>
            <p><strong>The GPU is an Army of 1,000 Interns.</strong> They aren't as smart as the Chef. They can't manage the restaurant. But if you shout "CHOP ONIONS!", 1,000 onions get chopped instantly.</p>
        </div>

        <!-- INTERACTIVE DEMO 1 (Kitchen Race) -->
        <div class="demo-container">
            <h3>Interactive Demo: The Chopping Race</h3>
            <p>Click the buttons below to process 20 items (onions).</p>
            <canvas id="raceCanvas" width="800" height="200" style="background: white; border: 1px solid #ddd; width: 100%; max-width: 800px;"></canvas>
            <div class="demo-controls">
                <button class="btn-demo btn-cpu" onclick="startRace('cpu')">Run CPU Mode (Sequential)</button>
                <button class="btn-demo btn-gpu" onclick="startRace('gpu')">Run GPU Mode (Parallel)</button>
            </div>
            <p id="raceStatus" style="font-weight: bold; height: 1.5em; margin-top: 10px;">Ready...</p>
        </div>

        <p>In computing, we call the Chef <strong>Serial Processing</strong> (one after another) and the Army <strong>Parallel Processing</strong> (all at once).</p>
    </section>

    <!-- SECTION 2: ARCHITECTURE -->
    <section id="architecture">
        <h2>2. How We Talk to the GPU (CUDA)</h2>
        <p>To use this "army of interns," we use a language called <strong>CUDA</strong> (Compute Unified Device Architecture) created by NVIDIA. It allows us to write standard C++ code that runs on the graphics card.</p>
        
        <h3>Host vs. Device</h3>
        <p>In CUDA, we always talk about two distinct places: </p>
        <ul>
            <li><strong>The Host (CPU):</strong> Where your main program starts. It controls the flow.</li>
            <li><strong>The Device (GPU):</strong> Where the heavy lifting (parallel math) happens.</li>
        </ul>

        <div class="highlight-box">
            <p><strong>The Golden Rule of CUDA:</strong> The GPU cannot read your computer's RAM directly. You must <code>malloc</code> (allocate) memory on the GPU and <code>memcpy</code> (copy) your data there before you can process it.</p>
        </div>
    </section>

    <!-- SECTION 3: HIERARCHY -->
    <section id="hierarchy">
        <h2>3. Organizing the Army: Grids and Blocks</h2>
        <p>CUDA organizes threads (workers) into a specific hierarchy: </p>
        
        <ul>
            <li><strong>Thread:</strong> A single worker (one intern).</li>
            <li><strong>Block:</strong> A team of workers. Threads in a block can talk to each other.</li>
            <li><strong>Grid:</strong> The entire collection of blocks (the whole factory).</li>
        </ul>

        <!-- INTERACTIVE DEMO 2 (Index Visualizer) -->
        <div class="demo-container">
            <h3>Interactive Tool: Visualizing the Global Index</h3>
            <p>Hover over a "thread" (small square) to see how CUDA calculates its unique ID.</p>
            
            <div class="math-display">
                Global Index (i) = (<span class="variable">blockIdx.x</span> &times; <span class="variable">blockDim.x</span>) + <span class="variable">threadIdx.x</span>
                <br>
                <span id="mathOutput" style="font-size: 1.5rem; margin-top: 10px; display: block; color: #aaa;">Hover over a square below...</span>
            </div>

            <div class="grid-visualizer" id="gridContainer">
                <!-- Blocks generated by JS -->
            </div>
        </div>

        <h3>The Magic Formula</h3>
        <p>Each thread needs to know <em>"Which piece of data do I work on?"</em> Since every thread runs the <strong>exact same code</strong>, they use their unique IDs to calculate their position (`i`) in the input array.</p>
        <pre><code class="c-type">int</code> i = blockDim.x * blockIdx.x + threadIdx.x;</pre>

        <hr style="border:0; border-top:1px dashed #ccc; margin: 40px 0;">
        
        <h3>The "Three-Legged Race" Rule (Warp Divergence)</h3>
        <p>Threads on the GPU are grouped into small packs called <strong>Warps</strong> (usually 32 threads). If threads in the same Warp take different branches of an <code>if/else</code> statement, they must execute both branches sequentially, slowing down the parallel benefit.</p>

        <!-- INTERACTIVE DEMO 3 (Warp Divergence) -->
        <div class="demo-container">
            <h3>Interactive Demo: Warp Divergence</h3>
            <p>See how <code>If/Else</code> logic affects execution time for a group (Warp) of 16 threads.</p>
            
            <div class="warp-container">
                <div class="warp-row" id="warpRow">
                    <!-- JS will fill this with threads -->
                </div>
            </div>

            <div class="timeline-bar">
                <div class="timeline-fill" id="timeFill"></div>
            </div>
            <p id="divergenceMsg" class="divergence-message">Waiting to run...</p>

            <div class="demo-controls">
                <button class="btn-demo btn-warp" onclick="runWarp('uniform')">Run Uniform (No If/Else)</button>
                <button class="btn-demo btn-gpu" onclick="runWarp('divergent')">Run Divergent (With If/Else)</button>
            </div>
        </div>
    </section>

    <!-- SECTION 4: THE FOCUSED CODE -->
    <section id="code">
        <h2>4. Focused Code: The Array Scaler Kernel</h2>
        <p>This simple kernel multiplies every element in an array by a constant factor. This is an ideal parallel task because each thread only needs to know its index and the factor—no thread needs to talk to any other.</p>

        <h3>The Kernel Code (GPU side)</h3>
        <pre><code class="c-comment">// The code that runs in parallel on the GPU's thousands of cores.</span
<span class="cuda-keyword">__global__</span> <span class="c-keyword">void</span> <span class="c-func">ArrayScaler</span>(<span class="c-keyword">float</span> *data, <span class="c-keyword">int</span> numElements, <span class="c-keyword">float</span> factor) {
    
    <span class="c-comment">// 1. The Global Index Calculation</span>
    <span class="c-type">int</span> i = blockDim.x * blockIdx.x + threadIdx.x;

    <span class="c-comment">// 2. Check boundary condition (Prevents array overflow)</span>
    <span class="c-keyword">if</span> (i < numElements) {
        <span class="c-comment">// 3. The Core Parallel Work</span>
        data[i] = data[i] * factor;
    }
}</code></pre>

        <h3>CUDA Keyword Glossary</h3>
        <ul>
            <li><span class="inline-code cuda-keyword">__global__</span>: A **function type qualifier**. This function runs on the **Device (GPU)** but is called from the **Host (CPU)**. This is a **Kernel**.</li>
            <li><span class="inline-code cuda-keyword">__device__</span>: (Not used here, but key) A function that runs on the **Device (GPU)** and is only callable by other functions on the Device.</li>
            <li><span class="inline-code special-launch">&lt;&lt;&lt;blocks, threads&gt;&gt;&gt;</span>: The **Execution Configuration**. This is how the Host tells the Device *how* to organize the workers when launching the Kernel.
                <ul>
                    <li>The first argument is the number of **Blocks** in the Grid.</li>
                    <li>The second argument is the number of **Threads** in each Block.</li>
                </ul>
            </li>
        </ul>

        <div class="analogy-box" style="border-left-color: #2ecc71; background-color: #e6f7e8;">
            <span class="analogy-title" style="color: #2ecc71;">The Kernel's Core Idea</span>
            <p>Every single thread runs the exact same code, but because each one calculates a unique index (`i`), they all end up working on a different, independent piece of data. This is **Single Instruction, Multiple Data (SIMD)**.</p>
        </div>

        <!-- INTERACTIVE DEMO 4 (Execution Simulator) -->
        <div class="demo-container">
            <h3>Interactive Execution Simulator</h3>
            <p>Click any thread below to see how the code executes for that specific worker, assuming a 50-element array and a factor of 2.0.</p>
            
            <div class="grid-visualizer" id="executionGridContainer" style="margin-bottom: 20px;">
                <!-- Blocks generated by JS for the simulator -->
            </div>
            
            <div id="executionOutput">
                Click a thread above to trace its execution steps.
            </div>
        </div>
    </section>

    <!-- SECTION 5: CONCLUSION -->
    <section id="conclusion">
        <h2>5. Conclusion</h2>
        <div class="highlight-box">
            <span class="analogy-title">Summary</span>
            <p>You have just unlocked the power of parallel computing. By moving the heavy lifting from the "Smart Chef" (CPU) to the "Army of Interns" (GPU), we can process millions of data points simultaneously.</p>
        </div>
        <p><strong>Key Takeaways:</strong></p>
        <ol>
            <li><strong>Parallelism:</strong> Do many simple things at once, not one complex thing fast.</li>
            <li><strong>Memory Management:</strong> You must move data to the GPU to use it.</li>
            <li><strong>Hierarchy:</strong> Threads are grouped into Blocks, Blocks are grouped into a Grid.</li>
        </ol>
    </section>

</div>

<footer>
    <p>Introduction to GPU Programming - Evaluation #1</p>
    <p>Created for the Class of 2025</p>
</footer>

<!-- SCRIPTS FOR INTERACTIVITY -->
<script>
    /* --- DEMO 1: KITCHEN RACE (Canvas) --- */
    const canvas = document.getElementById('raceCanvas');
    const ctx = canvas.getContext('2d');
    const items = 20;
    const itemSpacing = 35;
    const startX = 50;
    const itemY = 100;
    let mode = null; // 'cpu' or 'gpu'
    let progress = []; // Array to track progress of each item (0 to 100)
    let workers = [];  // Array of worker positions
    let animationId = null;
    let startTime = 0;
    let currentItemIndex = 0; // For CPU mode

    function initRace() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw Items (Onions)
        for(let i=0; i<items; i++) {
            let x = startX + i * itemSpacing;
            
            // Draw Item Circle
            ctx.beginPath();
            ctx.arc(x, itemY, 10, 0, Math.PI*2);
            ctx.fillStyle = progress[i] >= 100 ? '#2ecc71' : '#ddd'; // Green if done
            ctx.fill();
            ctx.strokeStyle = '#999';
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(i, x, itemY + 25);
        }
    }

    // Reset state
    for(let i=0; i<items; i++) progress[i] = 0;
    initRace();

    function startRace(selectedMode) {
        if(animationId) cancelAnimationFrame(animationId);
        mode = selectedMode;
        
        // Reset
        for(let i=0; i<items; i++) progress[i] = 0;
        currentItemIndex = 0;
        workers = [];
        
        if(mode === 'cpu') {
            // One worker starting at first item
            workers.push({x: startX, y: itemY - 40, targetIndex: 0});
            document.getElementById('raceStatus').innerText = "CPU: Processing one by one...";
        } else {
            // GPU: One worker PER item instantly
            for(let i=0; i<items; i++) {
                workers.push({x: startX + i * itemSpacing, y: itemY - 40, targetIndex: i});
            }
            document.getElementById('raceStatus').innerText = "GPU: All threads launched simultaneously!";
        }
        
        startTime = Date.now();
        animate();
    }

    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Logic
        let allDone = true;
        
        if(mode === 'cpu') {
            // CPU Logic: Process current index, then move to next
            if(currentItemIndex < items) {
                allDone = false;
                let worker = workers[0];
                let targetX = startX + currentItemIndex * itemSpacing;
                
                // Move worker to target
                if(Math.abs(worker.x - targetX) > 1) {
                    worker.x += (targetX - worker.x) * 0.2;
                } else {
                    // Chop!
                    progress[currentItemIndex] += 5; // Speed of chopping
                    if(progress[currentItemIndex] >= 100) {
                        progress[currentItemIndex] = 100;
                        currentItemIndex++;
                    }
                }
                
                // Draw Worker
                drawWorker(worker.x, worker.y, '#3498db');
            }
        } else {
            // GPU Logic: All work at once
            for(let i=0; i<workers.length; i++) {
                if(progress[i] < 100) {
                    progress[i] += 2; // Slightly slower per thread than CPU, but parallel
                    allDone = false;
                }
                drawWorker(workers[i].x, workers[i].y, '#e74c3c');
            }
        }

        // Draw Items (Redraw to show progress colors)
        for(let i=0; i<items; i++) {
            let x = startX + i * itemSpacing;
            ctx.beginPath();
            ctx.arc(x, itemY, 10, 0, Math.PI*2);
            // Dynamic fill based on progress
            if(progress[i] >= 100) ctx.fillStyle = '#2ecc71';
            else if (progress[i] > 0) ctx.fillStyle = '#f1c40f';
            else ctx.fillStyle = '#ddd';
            ctx.fill();
            ctx.strokeStyle = '#999';
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(i, x, itemY + 25);
        }

        if(!allDone) {
            animationId = requestAnimationFrame(animate);
        } else {
            let timeTaken = (Date.now() - startTime) / 1000;
            document.getElementById('raceStatus').innerText = "Done! Time: " + timeTaken.toFixed(2) + "s";
        }
    }

    function drawWorker(x, y, color) {
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI*2);
        ctx.fillStyle = color;
        ctx.fill();
        // Little head
        ctx.beginPath();
        ctx.arc(x, y-12, 5, 0, Math.PI*2);
        ctx.fillStyle = color;
        ctx.fill();
    }

    /* --- DEMO 2: THREAD GRID VISUALIZER --- */
    const gridContainer = document.getElementById('gridContainer');
    const mathOutput = document.getElementById('mathOutput');
    
    // Config: 3 Blocks, 4 Threads per block for Index Visualizer
    const numBlocksVis = 3;
    const threadsPerBlockVis = 5;

    // Generate HTML for Index Visualizer
    for(let b=0; b<numBlocksVis; b++) {
        let blockDiv = document.createElement('div');
        blockDiv.className = 'block-container';
        
        let label = document.createElement('div');
        label.className = 'block-label';
        label.innerText = `Block ${b}`;
        blockDiv.appendChild(label);

        let threadRow = document.createElement('div');
        threadRow.className = 'thread-row';

        for(let t=0; t<threadsPerBlockVis; t++) {
            let globalIdx = (b * threadsPerBlockVis) + t;

            let threadBox = document.createElement('div');
            threadBox.className = 'thread-box';
            threadBox.innerHTML = `<span class="t-id">T${t}</span><span class="g-idx">(i=${globalIdx})</span>`;
            
            // Hover Event
            threadBox.addEventListener('mouseenter', () => {
                mathOutput.innerHTML = `
                    <span class="result">${globalIdx}</span> = 
                    (<span class="variable">${b}</span> &times; <span class="variable">${threadsPerBlockVis}</span>) + 
                    <span class="variable">${t}</span>
                `;
            });

            threadRow.appendChild(threadBox);
        }
        
        blockDiv.appendChild(threadRow);
        gridContainer.appendChild(blockDiv);
    }

    // Reset text on mouse leave
    gridContainer.addEventListener('mouseleave', () => {
        mathOutput.innerHTML = `<span style="color:#aaa">Hover over a square below...</span>`;
    });

    /* --- DEMO 3: WARP DIVERGENCE --- */
    const warpRow = document.getElementById('warpRow');
    const timeFill = document.getElementById('timeFill');
    const divergenceMsg = document.getElementById('divergenceMsg');
    const warpSize = 16;
    let warpThreads = [];

    // Init Warp
    for(let i=0; i<warpSize; i++) {
        let t = document.createElement('div');
        t.className = 'warp-thread';
        warpRow.appendChild(t);
        warpThreads.push(t);
    }

    function runWarp(type) {
        // Reset
        timeFill.style.width = '0%';
        timeFill.style.transition = 'none';
        timeFill.style.backgroundColor = 'var(--primary)';
        warpThreads.forEach(t => t.style.backgroundColor = '#ddd');
        
        // Trigger Reflow
        void timeFill.offsetWidth;

        if (type === 'uniform') {
            divergenceMsg.innerText = "Running... All threads take same path.";
            divergenceMsg.style.color = '#2ecc71';
            
            // Animation: Fast Fill
            timeFill.style.transition = 'width 1s linear';
            timeFill.style.width = '100%'; 

            // Visual: All Green
            warpThreads.forEach(t => t.style.backgroundColor = '#2ecc71');

            setTimeout(() => {
                divergenceMsg.innerText = "Done! Time: 1 Cycle (Fast)";
            }, 1000);

        } else if (type === 'divergent') {
            divergenceMsg.innerText = "Running... Branch 1 (Evens only)";
            divergenceMsg.style.color = '#e74c3c';

            // Phase 1: Evens run, Odds wait
            timeFill.style.transition = 'width 1s linear';
            timeFill.style.width = '50%';
            
            warpThreads.forEach((t, i) => {
                if(i % 2 === 0) t.style.backgroundColor = '#3498db'; // Blue for path A
                else t.style.backgroundColor = '#999'; // Grey (Waiting)
            });

            setTimeout(() => {
                // Phase 2: Odds run, Evens wait
                divergenceMsg.innerText = "Running... Branch 2 (Odds only)";
                timeFill.style.transition = 'width 1s linear';
                timeFill.style.width = '100%'; // Full bar (Longer time)

                warpThreads.forEach((t, i) => {
                    if(i % 2 !== 0) t.style.backgroundColor = '#e74c3c'; // Red for path B
                    else t.style.backgroundColor = '#999'; // Grey (Waiting)
                });

                setTimeout(() => {
                    divergenceMsg.innerText = "Done! Time: 2 Cycles (Slow - Serialization happened!)";
                }, 1000);

            }, 1000);
        }
    }
    
    /* --- DEMO 4: KERNEL EXECUTION SIMULATOR --- */
    const executionGridContainer = document.getElementById('executionGridContainer');
    const executionOutput = document.getElementById('executionOutput');
    
    // Config for Execution Simulator
    const SIM_THREADS_PER_BLOCK = 4;
    const SIM_NUM_BLOCKS = 3;
    const SIM_NUM_ELEMENTS = 10; 
    const SIM_FACTOR = 2.0;

    // Generate HTML for Execution Simulator
    for(let b=0; b<SIM_NUM_BLOCKS; b++) {
        let blockDiv = document.createElement('div');
        blockDiv.className = 'block-container';
        
        let label = document.createElement('div');
        label.className = 'block-label';
        label.innerText = `Block ${b} (B.x=${b})`;
        blockDiv.appendChild(label);

        let threadRow = document.createElement('div');
        threadRow.className = 'thread-row';

        for(let t=0; t<SIM_THREADS_PER_BLOCK; t++) {
            let globalIdx = (b * SIM_THREADS_PER_BLOCK) + t;

            let threadBox = document.createElement('div');
            threadBox.className = 'thread-box';
            threadBox.innerHTML = `<span class="t-id">T${t}</span><span class="g-idx">(i=${globalIdx})</span>`;
            threadBox.dataset.blockX = b;
            threadBox.dataset.threadX = t;
            threadBox.dataset.globalIndex = globalIdx;

            // Click Event
            threadBox.addEventListener('click', function() {
                // Remove active state from all
                document.querySelectorAll('.thread-box').forEach(box => box.classList.remove('active'));
                
                // Add active state to clicked one
                this.classList.add('active');

                // Run Simulation
                simulateExecution(
                    parseInt(this.dataset.blockX), 
                    parseInt(this.dataset.threadX), 
                    parseInt(this.dataset.globalIndex)
                );
            });

            threadRow.appendChild(threadBox);
        }
        
        blockDiv.appendChild(threadRow);
        executionGridContainer.appendChild(blockDiv);
    }
    
    function simulateExecution(blockX, threadX, globalI) {
        let output = `<p style="font-size: 1.2rem; margin-bottom: 10px;"><strong>Kernel Trace for Thread T${threadX} (Block B${blockX})</strong></p>`;
        output += `<hr>`;
        
        // 1. Index Calculation Step
        output += `<p><strong>1. Global Index Calculation:</strong></p>`;
        output += `<pre style="background: var(--kernel-bg); color: white;">int i = blockDim.x * blockIdx.x + threadIdx.x;</pre>`;
        output += `<div><span class="variable">blockDim.x</span> = ${SIM_THREADS_PER_BLOCK} (Threads per Block)</div>`;
        output += `<div><span class="variable">blockIdx.x</span> = ${blockX} (Block ID)</div>`;
        output += `<div><span class="variable">threadIdx.x</span> = ${threadX} (Thread ID)</div>`;
        output += `<div style="font-weight: bold; margin-top: 5px;">Result: i = (${blockX} &times; ${SIM_THREADS_PER_BLOCK}) + ${threadX} = <span class="result">${globalI}</span></div>`;

        // 2. Boundary Check Step
        output += `<p style="margin-top: 15px;"><strong>2. Boundary Check:</strong></p>`;
        output += `<pre style="background: var(--kernel-bg); color: white;">if (i < numElements)</pre>`;
        let willExecute = globalI < SIM_NUM_ELEMENTS;
        let boundaryMsg = `Checking if <span class="result">${globalI}</span> < <span class="variable">${SIM_NUM_ELEMENTS}</span> (Total Array Size).`;
        
        output += `<div>${boundaryMsg}</div>`;

        // 3. The Core Work Step
        output += `<p style="margin-top: 15px;"><strong>3. Core Parallel Work:</strong></p>`;
        output += `<pre style="background: var(--kernel-bg); color: white;">data[i] = data[i] * factor;</pre>`;
        
        if (willExecute) {
            let initialValue = globalI + 10; // Mock data value
            let finalValue = initialValue * SIM_FACTOR;
            
            output += `<div style="color: #2ecc71; font-weight: bold;">Condition is TRUE: Thread executes.</div>`;
            output += `<div>Accessing data at index <span class="result">${globalI}</span>.</div>`;
            output += `<div>Input Value: ${initialValue.toFixed(2)}</div>`;
            output += `<div>Factor: <span class="variable">${SIM_FACTOR.toFixed(1)}</span></div>`;
            output += `<div style="font-weight: bold; margin-top: 5px;">Final Result: ${initialValue.toFixed(2)} &times; ${SIM_FACTOR.toFixed(1)} = <span class="result">${finalValue.toFixed(2)}</span></div>`;
        } else {
            output += `<div style="color: #e74c3c; font-weight: bold;">Condition is FALSE: Thread does NOT execute (Out of Bounds).</div>`;
            output += `<div>The work is skipped for this thread, saving memory and preventing errors.</div>`;
        }
        
        executionOutput.innerHTML = output;
    }
</script>

</body>
</html>